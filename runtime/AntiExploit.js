// Copyright (c) Manfred Foissner. All rights reserved.
// License: See LICENSE.txt in the project root.

// ============================================================
// AntiExploit.js - Economy Safety & Exploit Prevention
// ============================================================
// Detects: seed farming, reset abuse, EV/time spikes, dupe attempts
// Does NOT punish - flags + caps to maintain fair play feel
// ============================================================

import { State } from './State.js';
import { getConfig } from './DataLoader.js';

// ── In-memory tracking (persisted via State.meta.antiExploit) ──
function ensureAE() {
  if (!State.meta.antiExploit) {
    State.meta.antiExploit = {
      seedHistory: [],         // Last N seeds used, detect reuse
      resetLog: [],            // Zone reset timestamps
      evSnapshots: [],         // { time, scrap, cells, items } for EV/time
      flags: [],               // Active exploit flags
      totalResets: 0,
      sessionStart: Date.now()
    };
  }
}

// ── Configuration defaults ──
function getAEConfig() {
  return {
    maxSeedReuse:       getConfig('antiExploit.maxSeedReuse', 3),
    seedHistorySize:    getConfig('antiExploit.seedHistorySize', 50),
    resetCooldownMs:    getConfig('antiExploit.resetCooldownMs', 30000),  // 30s
    maxResetsPerHour:   getConfig('antiExploit.maxResetsPerHour', 10),
    evWindowMs:         getConfig('antiExploit.evWindowMs', 300000),      // 5 min
    evScrapSpikeThresh: getConfig('antiExploit.evScrapSpikeThresh', 5.0), // 5x normal
    evItemSpikeThresh:  getConfig('antiExploit.evItemSpikeThresh', 4.0),  // 4x normal
    scrapCapPerDepth:   getConfig('antiExploit.scrapCapPerDepth', 2000),  // soft cap
    enabled:            getConfig('antiExploit.enabled', true)
  };
}

export const AntiExploit = {

  // ═══════════════════════════════════════════════
  //  SEED FARMING DETECTION
  // ═══════════════════════════════════════════════
  // Tracks seed reuse. If same seed used > N times, drops are nerfed.

  onZoneEnter(seed) {
    ensureAE();
    const cfg = getAEConfig();
    if (!cfg.enabled) return { ok: true };

    const ae = State.meta.antiExploit;
    ae.seedHistory.push({ seed, time: Date.now() });

    // Trim history
    if (ae.seedHistory.length > cfg.seedHistorySize) {
      ae.seedHistory = ae.seedHistory.slice(-cfg.seedHistorySize);
    }

    // Count reuse
    const reuseCount = ae.seedHistory.filter(s => s.seed === seed).length;
    if (reuseCount > cfg.maxSeedReuse) {
      const flag = {
        type: 'SEED_FARMING',
        seed,
        reuseCount,
        time: Date.now(),
        action: 'DROP_NERF'
      };
      ae.flags.push(flag);
      console.warn('[ANTI-EXPLOIT] Seed farming detected: seed=' + seed + ' used ' + reuseCount + 'x');
      return { ok: false, flag, dropMult: Math.max(0.1, 1 / reuseCount) };
    }

    return { ok: true };
  },

  // Get current drop multiplier (1.0 = normal, <1.0 = nerfed)
  getDropMultiplier() {
    ensureAE();
    const cfg = getAEConfig();
    if (!cfg.enabled) return 1.0;

    const ae = State.meta.antiExploit;
    const currentSeed = State.run.currentSeed;
    if (!currentSeed) return 1.0;

    const reuseCount = ae.seedHistory.filter(s => s.seed === currentSeed).length;
    if (reuseCount > cfg.maxSeedReuse) {
      return Math.max(0.1, 1 / reuseCount);
    }
    return 1.0;
  },

  // ═══════════════════════════════════════════════
  //  RESET ABUSE DETECTION
  // ═══════════════════════════════════════════════
  // Detects rapid zone resets (dying/leaving to re-roll loot).

  onZoneReset() {
    ensureAE();
    const cfg = getAEConfig();
    if (!cfg.enabled) return { ok: true };

    const ae = State.meta.antiExploit;
    const now = Date.now();

    ae.resetLog.push(now);
    ae.totalResets++;

    // Trim log to last hour
    const oneHourAgo = now - 3600000;
    ae.resetLog = ae.resetLog.filter(t => t > oneHourAgo);

    // Check rate
    if (ae.resetLog.length > cfg.maxResetsPerHour) {
      const flag = {
        type: 'RESET_ABUSE',
        resetsThisHour: ae.resetLog.length,
        time: now,
        action: 'COOLDOWN'
      };
      ae.flags.push(flag);
      console.warn('[ANTI-EXPLOIT] Reset abuse: ' + ae.resetLog.length + ' resets/hour');
      return {
        ok: false,
        flag,
        cooldownRemaining: cfg.resetCooldownMs
      };
    }

    // Check cooldown between resets
    if (ae.resetLog.length >= 2) {
      const prev = ae.resetLog[ae.resetLog.length - 2];
      if (now - prev < cfg.resetCooldownMs) {
        return {
          ok: false,
          reason: 'Resetting too fast',
          cooldownRemaining: cfg.resetCooldownMs - (now - prev)
        };
      }
    }

    return { ok: true };
  },

  // ═══════════════════════════════════════════════
  //  EV/TIME SPIKE MONITORING
  // ═══════════════════════════════════════════════
  // Periodically snapshot economy values. Flag if rate of gain
  // exceeds expected baseline by threshold multiplier.

  snapshot() {
    ensureAE();
    const ae = State.meta.antiExploit;

    ae.evSnapshots.push({
      time: Date.now(),
      scrap: State.meta.scrap || 0,
      cells: State.run.cells || 0,
      items: State.run.stats?.itemsFound || 0,
      depth: State.run.currentDepth || 1
    });

    // Keep last 20 snapshots
    if (ae.evSnapshots.length > 20) {
      ae.evSnapshots = ae.evSnapshots.slice(-20);
    }
  },

  checkEVSpike() {
    ensureAE();
    const cfg = getAEConfig();
    if (!cfg.enabled) return { ok: true };

    const ae = State.meta.antiExploit;
    if (ae.evSnapshots.length < 2) return { ok: true };

    const recent = ae.evSnapshots[ae.evSnapshots.length - 1];
    const prev = ae.evSnapshots[ae.evSnapshots.length - 2];
    const dt = (recent.time - prev.time) / 1000;  // seconds
    if (dt < 1) return { ok: true };

    // Expected rates per second (baseline, scales with depth)
    const depth = recent.depth || 1;
    const baseScrapRate = 2 + depth * 0.5;   // scrap/sec baseline
    const baseItemRate = 0.01 + depth * 0.002; // items/sec baseline

    const actualScrapRate = (recent.scrap - prev.scrap) / dt;
    const actualItemRate = (recent.items - prev.items) / dt;

    const flags = [];

    if (actualScrapRate > baseScrapRate * cfg.evScrapSpikeThresh) {
      flags.push({
        type: 'EV_SPIKE_SCRAP',
        actual: actualScrapRate.toFixed(1),
        expected: baseScrapRate.toFixed(1),
        ratio: (actualScrapRate / baseScrapRate).toFixed(1),
        time: Date.now()
      });
    }

    if (actualItemRate > baseItemRate * cfg.evItemSpikeThresh) {
      flags.push({
        type: 'EV_SPIKE_ITEMS',
        actual: actualItemRate.toFixed(3),
        expected: baseItemRate.toFixed(3),
        ratio: (actualItemRate / baseItemRate).toFixed(1),
        time: Date.now()
      });
    }

    if (flags.length > 0) {
      ae.flags.push(...flags);
      console.warn('[ANTI-EXPLOIT] EV spike detected:', flags);
      return { ok: false, flags };
    }

    return { ok: true };
  },

  // ═══════════════════════════════════════════════
  //  SCRAP INFLATION CAP
  // ═══════════════════════════════════════════════
  // Soft cap: diminishing returns on scrap gain at high depth.

  applyScrapCap(rawScrap, depth) {
    ensureAE();
    const cfg = getAEConfig();
    if (!cfg.enabled) return rawScrap;

    const cap = cfg.scrapCapPerDepth * depth;
    const currentScrap = State.meta.scrap || 0;

    // If well below cap, full gain
    if (currentScrap < cap * 0.5) return rawScrap;

    // Soft cap: diminishing returns as you approach cap
    const ratio = currentScrap / cap;
    if (ratio >= 1.0) {
      // Hard diminish: only 10% gain
      return Math.ceil(rawScrap * 0.1);
    }
    if (ratio >= 0.75) {
      // Soft diminish: 50% gain
      return Math.ceil(rawScrap * 0.5);
    }

    return rawScrap;
  },

  // ═══════════════════════════════════════════════
  //  DIAGNOSTICS
  // ═══════════════════════════════════════════════

  getFlags() {
    ensureAE();
    return [...State.meta.antiExploit.flags];
  },

  clearFlags() {
    ensureAE();
    State.meta.antiExploit.flags = [];
  },

  getStats() {
    ensureAE();
    const ae = State.meta.antiExploit;
    return {
      totalResets: ae.totalResets,
      seedHistorySize: ae.seedHistory.length,
      activeFlags: ae.flags.length,
      evSnapshots: ae.evSnapshots.length,
      sessionAge: Math.round((Date.now() - ae.sessionStart) / 1000) + 's'
    };
  }
};

export default AntiExploit;
